#define  _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

//数据类型


//整型家族
//char 字符的本质是ASCII码值，是整型，所以划分到整型家族
//short
//int
//long
//long long 


//浮点型家族
//float
//double


//构造类型
//数组类型  int arr1[5] int [5]  int arr2[8]  int [8] 


//结构体类型 struct
//枚举类型 enum
//联合类型 union


//指针类型
//int* pi
//char* pc
//float* pf
//void* pv


//空类型
//void

//第一个void表示函数不会返回值
//第二个void表示函数不需要传任何参数

//void test(void)
//{
//	printf("hehe\n");
//}
//
//int main()
//{
//	test();
//	return 0;
//}


//整数的2进制表示有3种形式
//1.正的整数，原码、反码、补码相同
//2.负的整数，原码、反码、补码是需要计算的
//原码：直接通过正负的形式写出的二进制序列就是原码
//反码：原码的符号位不变，其他位按位取反得到的就是反码
//补码：反码+1就是补码

//int main()
//{
//	int a = 20;
//	//20
//	//00000000000000000000000000010100 原码
//	//0x00 00 00 14
//	//00000000000000000000000000010100 反码
//	//00000000000000000000000000010100 补码
//	int b = -10;
//	//10000000000000000000000000001010 原码
//	//0x80 00 00 0a
//	//11111111111111111111111111110101 反码
//	//0xff ff ff f5
//	//11111111111111111111111111110110 补码
//	//0xff ff ff f6
//
//	return 0;
//}

//在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理
//同时，加法和减法也可以统一处理(CPU只有加速器)此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路

//大小端
//大端【字节序】存储
//把一个数据的高位字节序的内容存放在低地址处，把低位字节序的内容放在高地址处，就是大段字节序存储

//小端【字节序】存储
//把一个数据的高位字节序的内容存放在高地址处，把低位字节序的内容放在低地址处，就是小端字节序存储

//int main()
//{
//	int a = 1;
//	if (*(char*)&a == 1)
//	{
//		printf("小端\n");
//	}
//	else
//	{
//		printf("大端\n");
//	}
//
//	return 0;
//}

//int check_sys()
//{
//	int a = 1;
//	return *(char*)&a;
//}
//
//int main()
//{
//	int ret = check_sys();
//	if (ret == 1)
//	{
//		printf("小端\n");
//	}
//	else
//	{
//		printf("大端\n");
//	}
//	return 0;
//}

//int main()
//{
//	char a = -1;
//	signed char b = -1;
//	unsigned char c = -1;
//
//	printf("a=%d,b=%d,c=%d", a, b, c);
//
//	return 0;
//}

//int main()
//{
//	unsigned int i;
//	for (i = 9; i >= 0; i--)
//	{
//		printf("%u\n", i);
//	}
//	return 0;
//}

//int main()
//{
//	char a[1000];
//	int i;
//
//	for (i = 0; i < 1000; i++)
//	{
//		a[i] = -1 - i;
//	}
//	//
//	//arr[i] --> char    -128~127
//	//-1 -2 -3 -4 ... -1000
//	//-1 -2 ... -128 127 126 ... 3 2 1 0 -1 ...
//	//128+127 = 255
//	printf("%d", strlen(a));
//	//strlen 是求字符串的长度，关注的是字符串中'\0'（数字0）之前出现多少个字符
//
//	return 0;
//}



//浮点型在内存中的存储

int main()
{
	int n = 9;
	//[00000000000000000000000000001001]
	//0 00000000 00000000000000000001001
	//E=-126
	//M=0.00000000000000000001001
	//+ 0.00000000000000000001001 * 2^-126 
	//无限趋近于0
	float* pFloat = (float*)&n;
	printf("n的值为:%d\n", n);
	printf("*pFloat的值为:%f\n", *pFloat);

	*pFloat = 9.0;
	//1001.0
	//1.001*2^3
	//S=0 E=3 M=1.001
	//0 10000010 00100000000000000000000
	//[01000001000100000000000000000000]
	printf("num的值为:%d\n", n);
	printf("pFloat的值为:%f\n", *pFloat);
	return 0;
}

//国际标准IEEE，任意一个二进制浮点数V可表示成下面的形式
//(-1)^S*M*2^E
//(-1)^S表示符号位，当S=0,V为正数；当S=1，V为负数。
//M表示有效数字，大于等于1，小于2.
//2^E表示指数位

//V=9.5f = 1001.1 = 1.0011 * 2^3 = (-1)^0 * 1.0011 * 2^3 S=0 M=1.0011 E=3

//浮点数存储规则（IEEE 754规定）

//对于32位的浮点数（float型），最高的1位是符号位S，接着的8位是指数E，剩下的23位为有效数字M。
//对于64位的浮点数（double型），最高的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M。

//对有效数字M和指数E，有一些特别规定

//在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存小数点后面的部分，将第一位的1舍去后，等于可以保存23位有效数字

//E为一个无符号整数，但科学计数法中E是可以出现负数的，IEEE规定，存入内存时E的真实值必须再加上一个中间数
//对于8位的E，这个中间数是127；对于11位的E，这个中间数是1023
//比如2^10的E是10，所以保存成32位浮点数时，必须保存成10+127=137，即10001001

//指数E从内存中取出还可以再分成三种情况
//1. E不为全0或全1
//指数E的存储值减去127（或1023），得到真实值，再将有效数字M前加上第一位的1

//2. E全为0
//此时，浮点数的指数等于-126（1-127）即为真实值，有效数字M不再加上第一位的1，而是还原为0.xxxx的小数，这样做是为了表示±0，以及接近于0的很小的数字


//3. E全为1
//此时，如果有效数字M全为0，表示±无穷大（正负取决于符号位S）


